<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego Roguelike 3D con Firebase</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- tweetnacl para verificación de firmas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tweetnacl/1.0.3/nacl.min.js"></script>
    
    <!-- Three.js y GLTF Loader para 3D -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        .card { background-color: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); }
        .btn-phantom { background: linear-gradient(90deg, #583cff, #a45cff); transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(117, 73, 255, 0.3); }
        .btn-phantom:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(117, 73, 255, 0.5); }
        #game-canvas-container { width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; }
        canvas { display: block; }
        .bar { background-color: rgba(0, 0, 0, 0.4); width: 200px; height: 20px; border-radius: 10px; overflow: hidden; border: 2px solid rgba(255,255,255,0.3); }
        .bar-fill { height: 100%; transition: width 0.2s ease-out; }
        #hp-bar-fill { background: linear-gradient(90deg, #ef4444, #f87171); }
        #xp-bar-fill { background: linear-gradient(90deg, #3b82f6, #60a5fa); }
        .power-card { transition: all 0.2s ease-in-out; border: 2px solid rgba(255,255,255,0.2); }
        .power-card:hover { transform: scale(1.05); border-color: #a45cff; }
        .power-cooldown { position: absolute; bottom: 0; left: 0; height: 4px; background-color: #60a5fa; transition: width 0.1s linear; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center">

    <!-- Pantalla de Selección de Poderes -->
    <div id="powerup-screen" class="hidden absolute inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center">
        <div class="text-center">
            <h2 class="text-4xl font-bold mb-8">¡Nivel Alcanzado! Elige una Mejora</h2>
            <div id="powerup-choices" class="flex gap-8">
                <!-- Las opciones de poderes se insertarán aquí -->
            </div>
        </div>
    </div>

    <!-- Contenedor Principal -->
    <div class="container mx-auto p-4 text-center w-full max-w-2xl z-10">

        <!-- Pantalla de Login -->
        <div id="login-screen" class="space-y-6 card p-8 rounded-2xl max-w-md mx-auto">
            <div class="flex justify-center">
                <!-- SVG logo Phantom -->
                <svg width="80" height="80" viewBox="0 0 101 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M50.5 101C78.39 101 101 78.39 101 50.5C101 22.61 78.39 0 50.5 0C22.61 0 0 22.61 0 50.5C0 78.39 22.61 101 50.5 101Z" fill="#201F25"></path><path d="M50.5 86.848C69.19 86.848 84.444 71.594 84.444 52.904C84.444 34.214 69.19 18.96 50.5 18.96C31.81 18.96 16.556 34.214 16.556 52.904C16.556 71.594 31.81 86.848 50.5 86.848Z" fill="url(#paint0_linear_14_254)"></path><path d="M50.5002 89.208C30.4182 89.208 14.1942 72.984 14.1942 52.902C14.1942 32.82 30.4182 16.596 50.5002 16.596C70.5822 16.596 86.8062 32.82 86.8062 52.902C86.8062 72.984 70.5822 89.208 50.5002 89.208ZM50.5002 18.956C31.8102 18.956 16.5562 34.21 16.5562 52.9C16.5562 71.59 31.8102 86.844 50.5002 86.844C69.1902 86.844 84.4442 71.59 84.4442 52.9C84.4442 34.21 69.1902 18.956 50.5002 18.956Z" fill="#A55CFD"></path><path d="M50.5 68.618C59.348 68.618 66.52 61.446 66.52 52.598C66.52 43.75 59.348 36.578 50.5 36.578C41.652 36.578 34.48 43.75 34.48 52.598C34.48 61.446 41.652 68.618 50.5 68.618Z" fill="white"></path><defs><linearGradient id="paint0_linear_14_254" x1="50.5" y1="18.96" x2="50.5" y2="86.848" gradientUnits="userSpaceOnUse"><stop stop-color="#A55CFD"></stop><stop offset="1" stop-color="#583CFF"></stop></linearGradient></defs></svg>
            </div>
            <h1 class="text-3xl font-bold">Phantom Roguelike 3D</h1>
            <p id="status-message" class="text-gray-400 h-6">Conecta tu billetera para explorar la mazmorra.</p>
            <button id="connect-wallet-btn" class="w-full btn-phantom text-white font-bold py-3 px-4 rounded-xl text-lg">
                Conectar con Phantom
            </button>
        </div>

        <!-- Pantalla de Juego -->
        <div id="game-screen" class="hidden">
            <div id="game-canvas-container"></div>
             <!-- UI superpuesta al juego -->
            <div class="absolute top-0 left-0 right-0 p-4 flex justify-between items-start bg-transparent z-10">
                 <div>
                    <p class="text-sm text-gray-400">Jugador:</p>
                    <p id="user-pubkey" class="font-mono text-xs md:text-sm truncate max-w-[200px] md:max-w-xs"></p>
                </div>
                <div id="powers-display" class="card p-2 rounded-lg flex flex-col items-center">
                    <p class="text-sm font-bold mb-1">PODERES</p>
                    <div id="powers-list" class="flex gap-2"></div>
                </div>
                <div class="flex items-center space-x-2">
                    <button id="save-game-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Guardar Progreso</button>
                    <button id="logout-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Desconectar</button>
                </div>
            </div>
            <div class="absolute bottom-4 left-1/2 -translate-x-1/2 card p-4 rounded-xl flex flex-col items-center space-y-2">
                <div id="player-stats" class="flex items-center space-x-6">
                    <div class="text-center">
                        <div id="hp-bar" class="bar"><div id="hp-bar-fill" class="bar-fill"></div></div>
                        <p id="player-hp-text" class="text-sm font-bold"></p>
                    </div>
                    <p class="font-bold text-2xl text-yellow-400" id="player-tokens">TOKENS: 0</p>
                     <div class="text-center">
                        <div id="xp-bar" class="bar"><div id="xp-bar-fill" class="bar-fill"></div></div>
                        <p id="player-xp-text" class="text-sm font-bold"></p>
                    </div>
                </div>
                <p class="text-lg text-gray-400" id="game-message">Usa W, A, S, D para moverte. Espacio para atacar.</p>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        
        // --- Elementos del DOM y Estado Global ---
        const connectButton = document.getElementById('connect-wallet-btn');
        const logoutButton = document.getElementById('logout-btn');
        const saveButton = document.getElementById('save-game-btn');
        const loginScreen = document.getElementById('login-screen');
        const gameScreen = document.getElementById('game-screen');
        const userPubKeyEl = document.getElementById('user-pubkey');
        const statusMessage = document.getElementById('status-message');
        const hpBarFill = document.getElementById('hp-bar-fill');
        const playerHpText = document.getElementById('player-hp-text');
        const xpBarFill = document.getElementById('xp-bar-fill');
        const playerXpText = document.getElementById('player-xp-text');
        const playerTokensEl = document.getElementById('player-tokens');
        const gameMessageEl = document.getElementById('game-message');
        const gameCanvasContainer = document.getElementById('game-canvas-container');
        const powerupScreen = document.getElementById('powerup-screen');
        const powerupChoices = document.getElementById('powerup-choices');
        const powersList = document.getElementById('powers-list');

        let provider = null;
        let userPublicKey = null;
        let gameState = {};
        let clock = new THREE.Clock();
        const keysPressed = {};
        let isPaused = false;
        const handleKeyDown = (e) => { keysPressed[e.code] = true; };
        const handleKeyUp = (e) => { keysPressed[e.code] = false; };
        
        // --- Configuración de Firebase ---
        const firebaseConfig = {
          apiKey: "AIzaSyDNKaie44jLjb8Xl2Si2nlbU5J_njT-2Kc",
          authDomain: "brainrotv2.firebaseapp.com",
          projectId: "brainrotv2",
          storageBucket: "brainrotv2.firebasestorage.app",
          messagingSenderId: "834208217383",
          appId: "1:834208217383:web:46d5539a0f2ae2b8ead102"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- Sistema de Poderes ---
        const POWERS = {
            fireball: { name: 'Bola de Fuego', type: 'active', maxLevel: 5, timer: 0, cooldown: 5,
                getDescription: (level) => `Lanza una bola de fuego cada ${ (5 - level * 0.5).toFixed(1) }s que inflige ${10 + level * 5} de daño.`,
                onUpdate: (delta, level) => {
                    POWERS.fireball.timer -= delta;
                    if (POWERS.fireball.timer <= 0) {
                        POWERS.fireball.cooldown = 5 - level * 0.5;
                        POWERS.fireball.timer = POWERS.fireball.cooldown;
                        const closestEnemy = findClosestEnemy(playerModel.position);
                        if (closestEnemy) createProjectile('fireball', playerModel.position, closestEnemy.mesh.position, 10 + level * 5);
                    }
                },
            },
            shockwave: { name: 'Onda Expansiva', type: 'active', maxLevel: 5, timer: 0, cooldown: 8,
                getDescription: (level) => `Emite una onda cada ${ (8 - level).toFixed(1) }s que inflige ${5 + level * 5} de daño en área.`,
                onUpdate: (delta, level) => {
                    POWERS.shockwave.timer -= delta;
                    if (POWERS.shockwave.timer <= 0) {
                        POWERS.shockwave.cooldown = 8 - level;
                        POWERS.shockwave.timer = POWERS.shockwave.cooldown;
                        createEffect('shockwave', playerModel.position, 5 + level * 5);
                    }
                },
            },
            max_hp_up: { name: 'Más Vida', type: 'passive', maxLevel: 10,
                getDescription: (level) => `Aumenta tu vida máxima en 20.`,
                onAcquire: (level) => {
                    gameState.maxHp += 20;
                    gameState.hp += 20;
                },
            }
        };

        // --- Lógica de la Billetera ---
        const getProvider = () => {
            if ('phantom' in window) {
                const solanaProvider = window.phantom?.solana;
                if (solanaProvider?.isPhantom) return solanaProvider;
            }
            return null;
        };
        const connectAndSign = async () => {
            provider = getProvider();
            if (!provider) { statusMessage.textContent = 'Billetera Phantom no encontrada.'; return; }
            try {
                statusMessage.textContent = 'Conectando billetera...';
                const resp = await provider.connect();
                userPublicKey = resp.publicKey;
                statusMessage.textContent = 'Firma el mensaje para iniciar sesión.';
                const messageText = `Firma este mensaje para jugar.\nNonce: ${Date.now()}`;
                const encodedMessage = new TextEncoder().encode(messageText);
                const { signature } = await provider.signMessage(encodedMessage, 'utf8');
                const isVerified = nacl.sign.detached.verify(encodedMessage, signature, userPublicKey.toBytes());
                if (isVerified) {
                    statusMessage.textContent = '¡Firma verificada! Cargando datos...';
                    await handleLoginSuccess();
                } else { throw new Error('La verificación de la firma falló.'); }
            } catch (err) {
                statusMessage.textContent = `Error: ${err.message || 'El usuario rechazó la solicitud.'}`;
                if (provider?.isConnected) await provider.disconnect();
            }
        };
        const logout = async () => {
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
            if (renderer) {
                renderer.dispose();
                gameCanvasContainer.innerHTML = '';
            }
            if (provider) await provider.disconnect();
            userPublicKey = null; provider = null;
            loginScreen.classList.remove('hidden');
            gameScreen.classList.add('hidden');
        };
        
        // --- Lógica de Base de Datos (Firestore) ---
        async function loadPlayerData(userId) {
            try {
                const playerDocRef = doc(db, "players", userId);
                const playerDoc = await getDoc(playerDocRef);
                if (playerDoc.exists()) {
                    return playerDoc.data();
                } else {
                    const defaultData = { hp: 100, maxHp: 100, damage: 10, position: { x: 0, z: 0 }, tokens: 0, powers: {}, level: 1, xp: 0, wave: 1 };
                    await savePlayerData(userId, defaultData);
                    return defaultData;
                }
            } catch (error) {
                console.error("Error al cargar datos del jugador:", error);
                return null;
            }
        }
        async function savePlayerData(userId, playerData) {
            try {
                const playerDocRef = doc(db, "players", userId);
                await setDoc(playerDocRef, playerData, { merge: true });
            } catch (error) {
                console.error("Error al guardar datos del jugador:", error);
            }
        }

        // --- Motor 3D y Lógica del Juego ---
        let scene, camera, renderer, playerModel, enemies = [], animationFrameId;
        let floatingTexts = [], projectiles = [], effects = [];
        let shakeDuration = 0, shakeIntensity = 0.25;
        const PLAYER_SPEED = 5.0;
        const ENEMY_SPEED = 2.5;
        const ATTACK_COOLDOWN = 1.0;
        let playerAttackTimer = ATTACK_COOLDOWN;
        const cameraOffset = new THREE.Vector3(20, 20, 20);


        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.copy(cameraOffset);
            camera.lookAt(new THREE.Vector3(0,0,0));
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(-30, 50, -30);
            scene.add(dirLight);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            gameCanvasContainer.innerHTML = '';
            gameCanvasContainer.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function generateMap3D() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshLambertMaterial({ color: 0x4a5568 }));
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            const wallGeo = new THREE.BoxGeometry(2, 2, 2);
            const wallMat = new THREE.MeshLambertMaterial({ color: 0x2d3748 });
            for(let i = -12; i <= 12; i++) {
                [-12, 12].forEach(j => {
                    const wallH = new THREE.Mesh(wallGeo, wallMat);
                    wallH.position.set(i * 2, 1, j * 2);
                    scene.add(wallH);
                    const wallV = new THREE.Mesh(wallGeo, wallMat);
                    wallV.position.set(j * 2, 1, i * 2);
                    scene.add(wallV);
                });
            }
        }
        
        function loadPlayerModel(playerData) {
            const loader = new GLTFLoader();
            loader.load('tralalero_tralala_brainrot.glb', (gltf) => {
                playerModel = gltf.scene;
                playerModel.scale.set(0.5, 0.5, 0.5);
                playerModel.position.set(playerData.position.x, 0, playerData.position.z);
                scene.add(playerModel);
            }, undefined, () => {
                const geometry = new THREE.BoxGeometry(1, 1.5, 1);
                const material = new THREE.MeshStandardMaterial({ color: 0x583cff });
                playerModel = new THREE.Mesh(geometry, material);
                playerModel.position.set(playerData.position.x, 0.75, playerData.position.z);
                scene.add(playerModel);
            });
        }

        function startNextWave() {
            gameState.wave++;
            const numEnemies = 5 + gameState.wave;
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            
            const enemyGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16);
            const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff4d4d });
            for (let i = 0; i < numEnemies; i++) {
                const mesh = new THREE.Mesh(enemyGeo, enemyMat);
                mesh.position.set((Math.random() * 40 - 20), 0.75, (Math.random() * 40 - 20));
                enemies.push({ mesh, hp: 50 * gameState.wave, maxHp: 50 * gameState.wave, damage: 5 + gameState.wave, tokenValue: 10, xpValue: 20, attackTimer: 1.5 });
                scene.add(mesh);
            }
        }

        function xpForNextLevel() {
            return 100 * Math.pow(1.5, gameState.level - 1);
        }

        function gainXP(amount) {
            if (gameState.hp <= 0) return;
            gameState.xp += amount;
            while (gameState.xp >= xpForNextLevel()) {
                gameState.xp -= xpForNextLevel();
                gameState.level++;
                isPaused = true;
                showPowerUpSelection();
            }
        }

        function updateUI() {
            // HP Bar
            const hpPercent = (gameState.hp / gameState.maxHp) * 100;
            hpBarFill.style.width = `${hpPercent}%`;
            playerHpText.textContent = `HP: ${Math.ceil(gameState.hp)} / ${gameState.maxHp}`;
            // XP Bar
            const xpPercent = (gameState.xp / xpForNextLevel()) * 100;
            xpBarFill.style.width = `${xpPercent}%`;
            playerXpText.textContent = `LVL ${gameState.level} (${Math.floor(gameState.xp)}/${Math.floor(xpForNextLevel())} XP)`;
            // Tokens
            playerTokensEl.textContent = `TOKENS: ${gameState.tokens}`;
            // Powers Cooldown
            updatePowersDisplay();
        }
        
        function updatePlayer(delta) {
            if (!playerModel || gameState.hp <= 0) return;

            playerAttackTimer += delta;
            
            const moveDirection = new THREE.Vector3(0, 0, 0);
            if (keysPressed['KeyW']) moveDirection.z -= 1;
            if (keysPressed['KeyS']) moveDirection.z += 1;
            if (keysPressed['KeyA']) moveDirection.x -= 1;
            if (keysPressed['KeyD']) moveDirection.x += 1;
            
            if (moveDirection.lengthSq() > 0) {
                moveDirection.normalize();
                
                const newPosition = playerModel.position.clone();
                newPosition.addScaledVector(moveDirection, PLAYER_SPEED * delta);
                
                const bounds = 23.5;
                newPosition.x = Math.max(-bounds, Math.min(bounds, newPosition.x));
                newPosition.z = Math.max(-bounds, Math.min(bounds, newPosition.z));
                
                playerModel.position.copy(newPosition);
            }
            
            if (keysPressed['Space'] && playerAttackTimer >= ATTACK_COOLDOWN) {
                playerAttackTimer = 0;
                enemies.forEach(enemy => {
                    if (playerModel.position.distanceTo(enemy.mesh.position) < 2.0) {
                        enemy.hp -= gameState.damage;
                        showFloatingText(`-${gameState.damage}`, enemy.mesh.position, '#ff4d4d');
                        if (enemy.hp <= 0) {
                           handleEnemyDeath(enemy);
                        }
                    }
                });
            }
        }
        
        function updateEnemies(delta) {
             if (!playerModel || gameState.hp <= 0) return;
             enemies.forEach(enemy => {
                enemy.attackTimer += delta;
                const distanceToPlayer = enemy.mesh.position.distanceTo(playerModel.position);
                
                if (distanceToPlayer > 1.5) {
                    const direction = playerModel.position.clone().sub(enemy.mesh.position).normalize();
                    enemy.mesh.position.addScaledVector(direction, ENEMY_SPEED * delta);
                } else if (enemy.attackTimer >= 1.5) {
                    enemy.attackTimer = 0;
                    gameState.hp -= enemy.damage;
                    showFloatingText(`-${enemy.damage}`, playerModel.position, '#ffffff');
                    shakeCamera(0.3, 0.25);
                     if (gameState.hp <= 0) {
                         gameState.hp = 0;
                         gameMessageEl.textContent = "¡Has sido derrotado!";
                     }
                }
             });
        }
        
        function handleEnemyDeath(enemy) {
            gainXP(enemy.xpValue);
            gameState.tokens += enemy.tokenValue;
            scene.remove(enemy.mesh);
            enemies = enemies.filter(e => e !== enemy);

            if (enemies.length === 0) {
                startNextWave();
            }
        }

        // --- Funciones de Poderes y Efectos ---
        function findClosestEnemy(position) {
            let closest = null;
            let minDistance = Infinity;
            enemies.forEach(enemy => {
                const distance = position.distanceTo(enemy.mesh.position);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = enemy;
                }
            });
            return closest;
        }

        function createProjectile(type, startPos, targetPos, damage) {
            const geo = new THREE.SphereGeometry(0.3, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(startPos);
            const direction = targetPos.clone().sub(startPos).normalize();
            projectiles.push({ mesh, direction, speed: 10, damage });
            scene.add(mesh);
        }

        function createEffect(type, position, damage) {
            if (type === 'shockwave') {
                const geo = new THREE.RingGeometry(0.1, 0.5, 32);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(position);
                mesh.rotation.x = -Math.PI / 2;
                effects.push({ mesh, damage, type, startTime: performance.now(), duration: 1000 });
                scene.add(mesh);
            }
        }

        function updatePowers(delta) {
             if (gameState.hp <= 0) return;
            for (const powerId in gameState.powers) {
                const powerData = POWERS[powerId];
                if (powerData.type === 'active') {
                    powerData.onUpdate(delta, gameState.powers[powerId].level);
                }
            }
        }

        function updateProjectilesAndEffects(delta) {
            projectiles.forEach((p, i) => {
                p.mesh.position.addScaledVector(p.direction, p.speed * delta);
                if (p.mesh.position.distanceTo(playerModel.position) > 50) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
                enemies.forEach(e => {
                    if (e && p && p.mesh && e.mesh && p.mesh.position.distanceTo(e.mesh.position) < 1.0) {
                        e.hp -= p.damage;
                        showFloatingText(`-${p.damage}`, e.mesh.position, '#ff4d4d');
                         if (e.hp <= 0) handleEnemyDeath(e);
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                    }
                });
            });

            effects.forEach((ef, i) => {
                const elapsed = performance.now() - ef.startTime;
                if (elapsed > ef.duration) {
                    scene.remove(ef.mesh);
                    effects.splice(i, 1);
                } else {
                    const progress = elapsed / ef.duration;
                    ef.mesh.scale.set(1 + progress * 10, 1 + progress * 10, 1);
                    ef.mesh.material.opacity = 1.0 - progress;

                    enemies.forEach(e => {
                        if (e && ef && ef.mesh && (!e.hitBy || !e.hitBy.includes(ef))) {
                            const dist = e.mesh.position.distanceTo(ef.mesh.position);
                            const currentRadius = ef.mesh.scale.x * 0.5;
                            if (dist < currentRadius && dist > currentRadius - 1) {
                                e.hp -= ef.damage;
                                showFloatingText(`-${ef.damage}`, e.mesh.position, '#ff4d4d');
                                if (!e.hitBy) e.hitBy = [];
                                e.hitBy.push(ef);
                                if (e.hp <= 0) handleEnemyDeath(e);
                            }
                        }
                    });
                }
            });
        }
        
        function showPowerUpSelection() {
            powerupChoices.innerHTML = '';
            const availablePicks = { ...POWERS };
            const choices = [];
            while (choices.length < 3 && Object.keys(availablePicks).length > 0) {
                const randomIndex = Math.floor(Math.random() * Object.keys(availablePicks).length);
                const randomKey = Object.keys(availablePicks)[randomIndex];
                const currentLevel = (gameState.powers && gameState.powers[randomKey]?.level) || 0;
                if (currentLevel < availablePicks[randomKey].maxLevel) {
                    choices.push(randomKey);
                }
                delete availablePicks[randomKey];
            }

            choices.forEach(powerId => {
                const power = POWERS[powerId];
                const currentLevel = (gameState.powers && gameState.powers[powerId]?.level) || 0;
                const card = document.createElement('div');
                card.className = 'power-card card p-6 rounded-lg cursor-pointer w-64';
                card.innerHTML = `
                    <h3 class="text-2xl font-bold text-purple-400">${power.name}</h3>
                    <p class="text-sm text-gray-300 mt-2">${power.getDescription(currentLevel + 1)}</p>
                    <p class="mt-4 font-bold text-green-400">NIVEL ${currentLevel + 1}</p>
                `;
                card.onclick = () => selectPowerUp(powerId);
                powerupChoices.appendChild(card);
            });
            powerupScreen.classList.remove('hidden');
        }

        function selectPowerUp(powerId) {
            if (!gameState.powers) gameState.powers = {};
            
            const currentLevel = gameState.powers[powerId]?.level || 0;
            gameState.powers[powerId] = { level: currentLevel + 1 };
            
            const power = POWERS[powerId];
            if (power.type === 'passive' && power.onAcquire) {
                power.onAcquire(currentLevel + 1);
            }
            
            savePlayerData(userPublicKey.toBase58(), gameState);
            
            powerupScreen.classList.add('hidden');
            isPaused = false;
        }

        function updatePowersDisplay() {
            powersList.innerHTML = '';
            for (const powerId in gameState.powers) {
                const power = POWERS[powerId];
                const level = gameState.powers[powerId].level;
                const el = document.createElement('div');
                el.className = 'text-center bg-gray-800 p-1 rounded relative overflow-hidden w-16';
                el.innerHTML = `<span class="text-xs font-bold">${power.name.substring(0,4)}</span><br/><span class="text-lg font-black">L${level}</span>`;
                if (power.type === 'active') {
                    const cooldownDiv = document.createElement('div');
                    cooldownDiv.className = 'power-cooldown';
                    cooldownDiv.id = `cooldown-${powerId}`;
                    el.appendChild(cooldownDiv);
                }
                powersList.appendChild(el);
            }
        }

        function createTextSprite(message, opts) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${opts.fontsize || 24}px ${opts.fontface || 'Inter'}`;
            canvas.width = context.measureText(message).width;
            canvas.height = opts.fontsize || 24;
            context.font = `Bold ${opts.fontsize || 24}px ${opts.fontface || 'Inter'}`;
            context.fillStyle = opts.color || '#FFFFFF';
            context.fillText(message, 0, opts.fontsize - 2);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(canvas.width/canvas.height * 2, 2, 1.0);
            return sprite;
        }

        function showFloatingText(text, position, color) {
            const sprite = createTextSprite(text, { fontsize: 32, color: color });
            sprite.position.copy(position).add(new THREE.Vector3(0, 1.5, 0));
            floatingTexts.push({ sprite: sprite, startTime: performance.now(), duration: 1500 });
            scene.add(sprite);
        }
        
        function shakeCamera(duration, intensity) {
            shakeDuration = duration;
            shakeIntensity = intensity;
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if (isPaused) return;

            const delta = clock.getDelta();
            
            updatePlayer(delta);
            updateEnemies(delta);
            updatePowers(delta);
            updateProjectilesAndEffects(delta);
            updateUI();

            const now = performance.now();
            floatingTexts.forEach((text, index) => {
                const elapsed = now - text.startTime;
                if (elapsed > text.duration) {
                    scene.remove(text.sprite);
                    floatingTexts.splice(index, 1);
                } else {
                    text.sprite.position.y += 0.02;
                    text.sprite.material.opacity = 1.0 - (elapsed / text.duration);
                }
            });
            
            if (playerModel) {
                const targetCameraPosition = playerModel.position.clone().add(cameraOffset);
                camera.position.copy(targetCameraPosition);
                
                if (shakeDuration > 0) {
                    camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                    camera.position.z += (Math.random() - 0.5) * shakeIntensity;
                    shakeDuration -= delta;
                }

                camera.lookAt(playerModel.position);
            }

            for (const powerId in gameState.powers) {
                 const power = POWERS[powerId];
                 if(power.type === 'active') {
                    const el = document.getElementById(`cooldown-${powerId}`);
                    if(el) el.style.width = `${100 - (power.timer / power.cooldown) * 100 }%`;
                 }
            }
            
            renderer.render(scene, camera);
        }

        const handleLoginSuccess = async () => {
            const userId = userPublicKey.toBase58();
            const playerData = await loadPlayerData(userId);
            
            if(!playerData) {
                statusMessage.textContent = "No se pudieron cargar los datos del jugador.";
                return;
            }
            
            gameState = {
                hp: 100, maxHp: 100, damage: 10, position: { x: 0, z: 0 }, tokens: 0, powers: {}, level: 1, xp: 0, wave: 0
                ,...playerData
            };
            
            loginScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            userPubKeyEl.textContent = userId;
            
            init3D();
            generateMap3D();
            loadPlayerModel(gameState);
            startNextWave();
            animate();
            
            // Recalculate stats based on passive powers on load
            let initialMaxHp = 100;
            if(gameState.powers && gameState.powers.max_hp_up) {
                initialMaxHp += 20 * gameState.powers.max_hp_up.level;
            }
            gameState.maxHp = initialMaxHp;
            if (gameState.hp > gameState.maxHp) gameState.hp = gameState.maxHp;

            updateUI();
            
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
        };

        // --- Event Listeners ---
        connectButton.addEventListener('click', connectAndSign);
        logoutButton.addEventListener('click', logout);
        saveButton.addEventListener('click', () => {
            if (!userPublicKey || !playerModel) return;
            gameState.position = { x: playerModel.position.x, z: playerModel.position.z };
            savePlayerData(userPublicKey.toBase58(), gameState);
        });
    </script>
</body>
</html>

