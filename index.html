<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego Roguelike 3D con Firebase</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- tweetnacl para verificación de firmas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tweetnacl/1.0.3/nacl.min.js"></script>
    
    <!-- Three.js y GLTF Loader para 3D -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        .card { background-color: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); }
        .btn-phantom { background: linear-gradient(90deg, #583cff, #a45cff); transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(117, 73, 255, 0.3); }
        .btn-phantom:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(117, 73, 255, 0.5); }
        #game-canvas-container { width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; }
        canvas { display: block; }
        .cooldown-bar { background-color: rgba(255, 255, 255, 0.2); width: 100px; height: 10px; border-radius: 5px; overflow: hidden; }
        .cooldown-fill { background-color: #4ade80; height: 100%; transition: width 0.1s linear; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center">

    <!-- Contenedor Principal -->
    <div class="container mx-auto p-4 text-center w-full max-w-2xl z-10">

        <!-- Pantalla de Login -->
        <div id="login-screen" class="space-y-6 card p-8 rounded-2xl max-w-md mx-auto">
            <div class="flex justify-center">
                <!-- SVG logo Phantom -->
                <svg width="80" height="80" viewBox="0 0 101 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M50.5 101C78.39 101 101 78.39 101 50.5C101 22.61 78.39 0 50.5 0C22.61 0 0 22.61 0 50.5C0 78.39 22.61 101 50.5 101Z" fill="#201F25"></path><path d="M50.5 86.848C69.19 86.848 84.444 71.594 84.444 52.904C84.444 34.214 69.19 18.96 50.5 18.96C31.81 18.96 16.556 34.214 16.556 52.904C16.556 71.594 31.81 86.848 50.5 86.848Z" fill="url(#paint0_linear_14_254)"></path><path d="M50.5002 89.208C30.4182 89.208 14.1942 72.984 14.1942 52.902C14.1942 32.82 30.4182 16.596 50.5002 16.596C70.5822 16.596 86.8062 32.82 86.8062 52.902C86.8062 72.984 70.5822 89.208 50.5002 89.208ZM50.5002 18.956C31.8102 18.956 16.5562 34.21 16.5562 52.9C16.5562 71.59 31.8102 86.844 50.5002 86.844C69.1902 86.844 84.4442 71.59 84.4442 52.9C84.4442 34.21 69.1902 18.956 50.5002 18.956Z" fill="#A55CFD"></path><path d="M50.5 68.618C59.348 68.618 66.52 61.446 66.52 52.598C66.52 43.75 59.348 36.578 50.5 36.578C41.652 36.578 34.48 43.75 34.48 52.598C34.48 61.446 41.652 68.618 50.5 68.618Z" fill="white"></path><defs><linearGradient id="paint0_linear_14_254" x1="50.5" y1="18.96" x2="50.5" y2="86.848" gradientUnits="userSpaceOnUse"><stop stop-color="#A55CFD"></stop><stop offset="1" stop-color="#583CFF"></stop></linearGradient></defs></svg>
            </div>
            <h1 class="text-3xl font-bold">Phantom Roguelike 3D</h1>
            <p id="status-message" class="text-gray-400 h-6">Conecta tu billetera para explorar la mazmorra.</p>
            <button id="connect-wallet-btn" class="w-full btn-phantom text-white font-bold py-3 px-4 rounded-xl text-lg">
                Conectar con Phantom
            </button>
        </div>

        <!-- Pantalla de Juego -->
        <div id="game-screen" class="hidden">
            <div id="game-canvas-container"></div>
             <!-- UI superpuesta al juego -->
            <div class="absolute top-0 left-0 right-0 p-4 flex justify-between items-center bg-transparent z-10">
                 <div>
                    <p class="text-sm text-gray-400">Jugador:</p>
                    <p id="user-pubkey" class="font-mono text-xs md:text-sm truncate max-w-[200px] md:max-w-xs"></p>
                </div>
                <div class="flex items-center space-x-2">
                    <button id="save-game-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Guardar Progreso</button>
                    <button id="logout-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Desconectar</button>
                </div>
            </div>
            <div class="absolute bottom-4 left-1/2 -translate-x-1/2 card p-4 rounded-xl text-center flex items-center space-x-6">
                 <p class="font-bold text-2xl" id="player-hp">HP: 10/10</p>
                 <p class="font-bold text-2xl text-yellow-400" id="player-tokens">TOKENS: 0</p>
                 <div class="flex flex-col items-center">
                    <p class="text-sm text-gray-400">ATAQUE (ESPACIO)</p>
                    <div class="cooldown-bar mt-1">
                        <div id="attack-cooldown-fill" class="cooldown-fill w-full"></div>
                    </div>
                </div>
                 <p class="text-lg text-gray-400" id="game-message">Usa las flechas para moverte.</p>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        
        // --- Elementos del DOM y Estado Global ---
        const connectButton = document.getElementById('connect-wallet-btn');
        const logoutButton = document.getElementById('logout-btn');
        const saveButton = document.getElementById('save-game-btn');
        const loginScreen = document.getElementById('login-screen');
        const gameScreen = document.getElementById('game-screen');
        const userPubKeyEl = document.getElementById('user-pubkey');
        const statusMessage = document.getElementById('status-message');
        const playerHpEl = document.getElementById('player-hp');
        const playerTokensEl = document.getElementById('player-tokens');
        const gameMessageEl = document.getElementById('game-message');
        const gameCanvasContainer = document.getElementById('game-canvas-container');
        const attackCooldownFill = document.getElementById('attack-cooldown-fill');

        let provider = null;
        let userPublicKey = null;
        let gameState = {};
        let clock = new THREE.Clock();
        const keysPressed = {};
        
        // --- Configuración de Firebase ---
        const firebaseConfig = {
          apiKey: "AIzaSyDNKaie44jLjb8Xl2Si2nlbU5J_njT-2Kc",
          authDomain: "brainrotv2.firebaseapp.com",
          projectId: "brainrotv2",
          storageBucket: "brainrotv2.firebasestorage.app",
          messagingSenderId: "834208217383",
          appId: "1:834208217383:web:46d5539a0f2ae2b8ead102"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- Lógica de la Billetera ---
        const getProvider = () => {
            if ('phantom' in window) {
                const solanaProvider = window.phantom?.solana;
                if (solanaProvider?.isPhantom) return solanaProvider;
            }
            return null;
        };

        const connectAndSign = async () => {
            provider = getProvider();
            if (!provider) { statusMessage.textContent = 'Billetera Phantom no encontrada.'; return; }
            try {
                statusMessage.textContent = 'Conectando billetera...';
                const resp = await provider.connect();
                userPublicKey = resp.publicKey;
                
                statusMessage.textContent = 'Firma el mensaje para iniciar sesión.';
                const messageText = `Firma este mensaje para jugar.\nNonce: ${Date.now()}`;
                const encodedMessage = new TextEncoder().encode(messageText);
                const { signature } = await provider.signMessage(encodedMessage, 'utf8');
                const isVerified = nacl.sign.detached.verify(encodedMessage, signature, userPublicKey.toBytes());

                if (isVerified) {
                    statusMessage.textContent = '¡Firma verificada! Cargando datos...';
                    await handleLoginSuccess();
                } else { throw new Error('La verificación de la firma falló.'); }
            } catch (err) {
                statusMessage.textContent = `Error: ${err.message || 'El usuario rechazó la solicitud.'}`;
                if (provider?.isConnected) await provider.disconnect();
            }
        };

        const logout = async () => {
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            window.removeEventListener('keydown', (e) => keysPressed[e.code] = true);
            window.removeEventListener('keyup', (e) => keysPressed[e.code] = false);
            if (renderer) {
                renderer.dispose();
                gameCanvasContainer.innerHTML = '';
            }
            if (provider) await provider.disconnect();
            userPublicKey = null; provider = null;
            loginScreen.classList.remove('hidden');
            gameScreen.classList.add('hidden');
        };
        
        // --- Lógica de Base de Datos (Firestore) ---
        async function loadPlayerData(userId) {
            try {
                const playerDocRef = doc(db, "players", userId);
                const playerDoc = await getDoc(playerDocRef);

                if (playerDoc.exists()) {
                    return playerDoc.data();
                } else {
                    const defaultData = { hp: 100, maxHp: 100, damage: 10, position: { x: 0, z: 0 }, tokens: 0 };
                    await savePlayerData(userId, defaultData);
                    return defaultData;
                }
            } catch (error) {
                console.error("Error al cargar datos del jugador:", error);
                return null;
            }
        }

        async function savePlayerData(userId, playerData) {
            try {
                gameMessageEl.textContent = "Guardando...";
                const playerDocRef = doc(db, "players", userId);
                await setDoc(playerDocRef, playerData, { merge: true });
                gameMessageEl.textContent = "¡Progreso guardado en la nube!";
            } catch (error) {
                console.error("Error al guardar datos del jugador:", error);
            }
        }

        // --- Motor 3D y Lógica del Juego ---
        let scene, camera, renderer, playerModel, enemies = [], animationFrameId, exitPortal;
        let floatingTexts = [];
        let shakeDuration = 0, shakeIntensity = 0.25;
        const PLAYER_SPEED = 5.0;
        const ENEMY_SPEED = 2.5;
        const ATTACK_COOLDOWN = 1.0; // seconds
        let playerAttackTimer = ATTACK_COOLDOWN;

        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(20, 20, 20);
            camera.lookAt(scene.position);
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(-30, 50, -30);
            scene.add(dirLight);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            gameCanvasContainer.innerHTML = '';
            gameCanvasContainer.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function generateMap3D() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshLambertMaterial({ color: 0x4a5568 }));
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            const wallGeo = new THREE.BoxGeometry(2, 2, 2);
            const wallMat = new THREE.MeshLambertMaterial({ color: 0x2d3748 });
            for(let i = -12; i <= 12; i++) {
                [-12, 12].forEach(j => {
                    const wallH = new THREE.Mesh(wallGeo, wallMat);
                    wallH.position.set(i * 2, 1, j * 2);
                    scene.add(wallH);
                    const wallV = new THREE.Mesh(wallGeo, wallMat);
                    wallV.position.set(j * 2, 1, i * 2);
                    scene.add(wallV);
                });
            }
        }
        
        function loadPlayerModel(playerData) {
            const loader = new GLTFLoader();
            loader.load('tralalero_tralala_brainrot.glb', (gltf) => {
                playerModel = gltf.scene;
                playerModel.scale.set(0.5, 0.5, 0.5);
                playerModel.position.set(playerData.position.x, 0, playerData.position.z);
                scene.add(playerModel);
            }, undefined, () => {
                const geometry = new THREE.BoxGeometry(1, 1.5, 1);
                const material = new THREE.MeshStandardMaterial({ color: 0x583cff });
                playerModel = new THREE.Mesh(geometry, material);
                playerModel.position.set(playerData.position.x, 0.75, playerData.position.z);
                scene.add(playerModel);
            });
        }

        function createEnemies() {
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            const enemyGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16);
            const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff4d4d });
            for (let i = 0; i < 5; i++) {
                const mesh = new THREE.Mesh(enemyGeo, enemyMat);
                mesh.position.set((Math.random() * 20 - 10), 0.75, (Math.random() * 20 - 10));
                const enemy = { mesh, hp: 50, maxHp: 50, damage: 5, tokenValue: 10, attackTimer: 1.5 };
                enemies.push(enemy);
                scene.add(mesh);
            }
        }
        
        function updatePlayer(delta) {
            if (!playerModel || gameState.hp <= 0) return;

            playerAttackTimer += delta;
            attackCooldownFill.style.width = `${Math.min(playerAttackTimer / ATTACK_COOLDOWN, 1) * 100}%`;

            const moveDirection = new THREE.Vector3(0, 0, 0);
            if (keysPressed['ArrowUp'] || keysPressed['KeyW']) moveDirection.z -= 1;
            if (keysPressed['ArrowDown'] || keysPressed['KeyS']) moveDirection.z += 1;
            if (keysPressed['ArrowLeft'] || keysPressed['KeyA']) moveDirection.x -= 1;
            if (keysPressed['ArrowRight'] || keysPressed['KeyD']) moveDirection.x += 1;
            
            if (moveDirection.lengthSq() > 0) {
                moveDirection.normalize();
                playerModel.position.addScaledVector(moveDirection, PLAYER_SPEED * delta);
            }
            
            if (keysPressed['Space'] && playerAttackTimer >= ATTACK_COOLDOWN) {
                playerAttackTimer = 0;
                const attackDirection = moveDirection.lengthSq() > 0 ? moveDirection : new THREE.Vector3(0,0,-1);
                animateAttack(playerModel, attackDirection, 1, 150);
                
                enemies.forEach(enemy => {
                    if (playerModel.position.distanceTo(enemy.mesh.position) < 2.0) {
                        enemy.hp -= gameState.damage;
                        showFloatingText(`-${gameState.damage}`, enemy.mesh.position, '#ff4d4d');
                        if (enemy.hp <= 0) {
                            gameState.tokens += enemy.tokenValue;
                            playerTokensEl.textContent = `TOKENS: ${gameState.tokens}`;
                            showFloatingText(`+${enemy.tokenValue}T`, enemy.mesh.position, '#ffd700');
                            scene.remove(enemy.mesh);
                            enemies = enemies.filter(e => e !== enemy);
                        }
                    }
                });
            }
        }
        
        function updateEnemies(delta) {
             if (!playerModel || gameState.hp <= 0) return;
             enemies.forEach(enemy => {
                enemy.attackTimer += delta;
                const distanceToPlayer = enemy.mesh.position.distanceTo(playerModel.position);
                
                if (distanceToPlayer > 1.5) {
                    const direction = playerModel.position.clone().sub(enemy.mesh.position).normalize();
                    enemy.mesh.position.addScaledVector(direction, ENEMY_SPEED * delta);
                } else if (enemy.attackTimer >= 1.5) {
                    enemy.attackTimer = 0;
                    gameState.hp -= enemy.damage;
                    playerHpEl.textContent = `HP: ${Math.max(0, gameState.hp)}/${gameState.maxHp}`;
                    showFloatingText(`-${enemy.damage}`, playerModel.position, '#ff4d4d');
                    shakeCamera(0.3, 0.25);
                     if (gameState.hp <= 0) {
                        gameMessageEl.textContent = "¡Has sido derrotado!";
                    }
                }
             });
        }
        
        function animateAttack(model, direction, distance = 1, duration = 100) {
            const startPos = model.position.clone();
            const startTime = performance.now();
            function lunge() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const backAndForth = Math.sin(progress * Math.PI);
                model.position.copy(startPos).addScaledVector(direction, backAndForth * distance);
                if (progress < 1) requestAnimationFrame(lunge);
                else model.position.copy(startPos);
            }
            lunge();
        }

        function createTextSprite(message, opts) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${opts.fontsize || 24}px ${opts.fontface || 'Inter'}`;
            canvas.width = context.measureText(message).width;
            canvas.height = opts.fontsize || 24;
            context.font = `Bold ${opts.fontsize || 24}px ${opts.fontface || 'Inter'}`;
            context.fillStyle = opts.color || '#FFFFFF';
            context.fillText(message, 0, opts.fontsize - 2);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(canvas.width/canvas.height * 2, 2, 1.0);
            return sprite;
        }

        function showFloatingText(text, position, color) {
            const sprite = createTextSprite(text, { fontsize: 32, color: color });
            sprite.position.copy(position).add(new THREE.Vector3(0, 1.5, 0));
            floatingTexts.push({ sprite: sprite, startTime: performance.now(), duration: 1500 });
            scene.add(sprite);
        }
        
        function shakeCamera(duration, intensity) {
            shakeDuration = duration;
            shakeIntensity = intensity;
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            updatePlayer(delta);
            updateEnemies(delta);

            const now = performance.now();
            floatingTexts.forEach((text, index) => {
                const elapsed = now - text.startTime;
                if (elapsed > text.duration) {
                    scene.remove(text.sprite);
                    floatingTexts.splice(index, 1);
                } else {
                    text.sprite.position.y += 0.02;
                    text.sprite.material.opacity = 1.0 - (elapsed / text.duration);
                }
            });

            if (shakeDuration > 0) {
                camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                camera.position.z += (Math.random() - 0.5) * shakeIntensity;
                shakeDuration -= delta;
            } else {
                camera.lookAt(scene.position);
            }

            renderer.render(scene, camera);
        }

        const handleLoginSuccess = async () => {
            const userId = userPublicKey.toBase58();
            const playerData = await loadPlayerData(userId);
            
            if(!playerData) {
                statusMessage.textContent = "No se pudieron cargar los datos del jugador.";
                return;
            }
            
            gameState = {
                hp: 100, maxHp: 100, damage: 10, position: { x: 0, z: 0 }, tokens: 0,
                ...playerData
            };
            
            loginScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            userPubKeyEl.textContent = userId;
            playerHpEl.textContent = `HP: ${gameState.hp}/${gameState.maxHp}`;
            playerTokensEl.textContent = `TOKENS: ${gameState.tokens}`;
            
            init3D();
            generateMap3D();
            loadPlayerModel(gameState);
            createEnemies();
            animate();
            window.addEventListener('keydown', (e) => keysPressed[e.code] = true);
            window.addEventListener('keyup', (e) => keysPressed[e.code] = false);
        };

        // --- Event Listeners ---
        connectButton.addEventListener('click', connectAndSign);
        logoutButton.addEventListener('click', logout);
        saveButton.addEventListener('click', () => {
            if (!userPublicKey || !playerModel) return;
            gameState.position = { x: playerModel.position.x, z: playerModel.position.z };
            savePlayerData(userPublicKey.toBase58(), gameState);
        });
    </script>
</body>
</html>

